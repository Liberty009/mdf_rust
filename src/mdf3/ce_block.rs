use crate::utils;

use super::mdf3_block::Mdf3Block;

#[derive(Debug, Clone, PartialEq)]
pub struct Ceblock {
    pub block_type: [u8; 2],
    pub block_size: u16,
    pub extension_type: u16,
    pub additional: Vec<u8>,
}

impl Mdf3Block for Ceblock {
    fn read(stream: &[u8], position: usize, little_endian: bool) -> (usize, Self) {
        let mut pos = position;
        let block_type: [u8; 2] = utils::read(stream, little_endian, &mut pos);
        let block_size = utils::read(stream, little_endian, &mut pos);
        let extension_type = utils::read(stream, little_endian, &mut pos);

        let additional = stream[pos..block_size as usize].to_vec();

        (
            pos,
            Ceblock {
                block_type,
                block_size,
                extension_type,
                additional,
            },
        )
    }
}

impl Ceblock {
    #[allow(dead_code)]
    pub fn write() {}
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn read() {
        let ce_data = [
            0x43, 0x45, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x68,
            0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x65, 0x64,
            0x20, 0x62, 0x79, 0x20, 0x50, 0x79, 0x74, 0x68, 0x6F, 0x6E, 0x20, 0x53, 0x63, 0x72,
            0x69, 0x70, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x43, 0x4E, 0xE4, 0x00, 0xA6, 0xE3, 0x10, 0x00, 0x80, 0xE0, 0x10, 0x00,
            0xAE, 0xE0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x74, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let (_position, ce_block) = Ceblock::read(&ce_data, 0, true);

        // assert_eq!(position, 0);
        assert_eq!(ce_block.block_size, 128);
        assert_eq!(ce_block.extension_type, 2);
    }

    #[test]
    fn write() {}
}
