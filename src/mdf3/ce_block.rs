use crate::utils;

use super::mdf3_block::Mdf3Block;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Ceblock {
    block_type: [u8; 2],
    block_size: u16,
    extension_type: u16,
    additional: Vec<u8>,
}

impl Mdf3Block for Ceblock {
    fn read(stream: &[u8], position: usize, little_endian: bool) -> (usize, Self) {
        let mut pos = position;
        let block_type: [u8; 2] = utils::read(stream, little_endian, &mut pos);
        let block_size = utils::read(stream, little_endian, &mut pos);
        let extension_type = utils::read(stream, little_endian, &mut pos);

        let additional = stream[pos..block_size as usize].to_vec();

        (
            pos,
            Ceblock {
                block_type,
                block_size,
                extension_type,
                additional,
            },
        )
    }

    fn write(&self, _start_position: usize, little_endian: bool) -> Vec<u8> {
        let mut array = Vec::new();
        array.append(&mut self.block_type.to_vec());
        array.append(&mut utils::write(self.block_size, little_endian));
        array.append(&mut utils::write(self.extension_type, little_endian));
        array.append(&mut self.additional.clone());

        array
    }
}

impl Ceblock {
    pub fn write() {}
}

#[cfg(test)]
mod tests {
    use super::*;

    static CE_DATA: [u8; 204] = [
        0x43, 0x45, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x68, 0x61,
        0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x65, 0x64, 0x20, 0x62,
        0x79, 0x20, 0x50, 0x79, 0x74, 0x68, 0x6F, 0x6E, 0x20, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x4E, 0xE4, 0x00, 0xA6, 0xE3, 0x10,
        0x00, 0x80, 0xE0, 0x10, 0x00, 0xAE, 0xE0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x74, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn read() {
        let (_position, ce_block) = Ceblock::read(&CE_DATA, 0, true);

        // assert_eq!(position, 0);
        assert_eq!(ce_block.block_size, 128);
        assert_eq!(ce_block.extension_type, 2);
    }

    #[test]
    fn write() {
        let (_position, ce_block) = Ceblock::read(&CE_DATA, 0, true);

        let write_array = ce_block.write(0, true);

        assert!(utils::eq(&CE_DATA, &write_array));
    }
}
