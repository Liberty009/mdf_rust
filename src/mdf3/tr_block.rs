#[derive(Debug, Clone)]
pub struct Trblock {
    block_type: [u8; 2],
    block_size: u16,
    trigger_comment: u32,
    trigger_events_number: u16,
    events: Vec<Event>,
}

impl Mdf3Block for Trblock {
    fn read(stream: &[u8], position: usize, little_endian: bool) -> (usize, Self) {
        let mut pos = position;

        let block_type: [u8; 2] = utils::read(&stream[pos..], little_endian, &mut pos);
        if !utils::eq(&block_type, "TR".as_bytes()) {
            panic!(
                "TRBLOCK not found. Found: {}, {}",
                block_type[0], block_type[1]
            );
        }

        pos += block_type.len();

        let block_size = utils::read(&stream[pos..], little_endian, &mut pos);
        let trigger_comment = utils::read(&stream[pos..], little_endian, &mut pos);
        let trigger_events_number = utils::read(stream, little_endian, &mut pos);
        let (events, pos) = Trblock::read_events(stream, pos, little_endian, trigger_events_number);

        (
            pos,
            Trblock {
                block_type,
                block_size,
                trigger_comment,
                trigger_events_number,
                events,
            },
        )
    }

    fn write(&self, _start_position: usize, little_endian: bool) -> Vec<u8> {
        let mut array = Vec::new();

        array.append(&mut self.block_type.to_vec());
        array.append(&mut utils::write(self.block_size, little_endian));
        array.append(&mut utils::write(self.trigger_comment, little_endian));
        array.append(&mut utils::write(self.trigger_events_number, little_endian));

        for event in &self.events {
            array.append(&mut event.write(little_endian));
        }

        array
    }
}

impl Trblock {

    pub fn read_events(
        stream: &[u8],
        position: usize,
        little_endian: bool,
        no_events: u16,
    ) -> (Vec<Event>, usize) {
        let mut events = Vec::with_capacity(no_events as usize + 1);
        let mut pos1 = position;
        for _i in 0..no_events {
            let (event, pos) = Event::read(stream, pos1, little_endian);
            events.push(event);
            pos1 += pos;
        }

        (events, position)
    }
}

// #[cfg(test)]
// mod tests {
//     use super::*;

//     #[test]
//     fn read() {
//         let tr_data = [
//             0x54, 0x52, 0x3A, 0x00, 0xB7, 0xE4, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCD, 0xF3, 0x8C, 0xEF, 0x1E, 0x6B, 0x0E, 0x40,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x43, 0x43, 0x2E, 0x00, 0x01, 0x00, 0x10, 0xA4, 0x20, 0x1C, 0x58, 0x33,
//             0x97, 0x3F, 0x12, 0x5B, 0x1A, 0xC4, 0x49, 0xD3, 0x28, 0x40, 0x73, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x43, 0x4E, 0xE4, 0x00, 0x63, 0xE7, 0x10, 0x00,
//             0x65, 0xE5, 0x10, 0x00, 0xAE, 0xE0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x01, 0x00, 0x74, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
//             0x03, 0x00, 0x01, 0x00, 0x10, 0xA4, 0x20, 0x1C, 0x58, 0x33, 0x97, 0x3F, 0x12, 0x5B,
//             0x1A, 0xC4, 0x49, 0xD3, 0x28, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x58,
//         ];

//         let (tr_block, position) = TRBLOCK::read(&tr_data, true, 0);

//         assert_eq!(position, 58);
//         assert_eq!(tr_block.block_size, 58);
//         assert_eq!(tr_block.trigger_comment, 1107127);
//         assert_eq!(tr_block.trigger_events_number, 2);
//     }

//     #[test]
//     fn write() {}
// }

use crate::utils;

use super::{event::Event, mdf3_block::Mdf3Block};
