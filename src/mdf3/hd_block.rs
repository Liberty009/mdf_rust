use crate::utils;

use super::{dg_block::Dgblock, mdf3_block::Mdf3Block, tx_block::Txblock};

#[derive(Debug, Clone, Copy)]
pub struct Hdblock {
    #[allow(dead_code)]
    position: usize,
    #[allow(dead_code)]
    block_type: [u8; 2],
    #[allow(dead_code)]
    block_size: u16,
    data_group_block: u32,
    file_comment: u32,
    #[allow(dead_code)]
    program_block: u32,
    #[allow(dead_code)]
    data_group_number: u16,
    #[allow(dead_code)]
    date: [u8; 10],
    #[allow(dead_code)]
    time: [u8; 8],
    #[allow(dead_code)]
    author: [u8; 32],
    #[allow(dead_code)]
    department: [u8; 32],
    #[allow(dead_code)]
    project: [u8; 32],
    #[allow(dead_code)]
    subject: [u8; 32],
    #[allow(dead_code)]
    timestamp: u64,
    #[allow(dead_code)]
    utc_time_offset: i16,
    #[allow(dead_code)]
    time_quality: u16,
    #[allow(dead_code)]
    timer_id: [u8; 32],
}

impl Mdf3Block for Hdblock {
    fn read(stream: &[u8], position: usize, little_endian: bool) -> (usize, Self) {
        let mut pos = position;
        let block_type: [u8; 2] = utils::read(stream, little_endian, &mut pos);

        if !utils::eq(&block_type, "HD".as_bytes()) {
            panic!("Incorrect type for HDBLOCK");
        }

        let block_size = utils::read(stream, little_endian, &mut pos);
        let data_group_block = utils::read(stream, little_endian, &mut pos);
        let file_comment = utils::read(stream, little_endian, &mut pos);
        let program_block = utils::read(stream, little_endian, &mut pos);
        let data_group_number = utils::read(stream, little_endian, &mut pos);
        let date: [u8; 10] = utils::read(stream, little_endian, &mut pos);
        let time: [u8; 8] = utils::read(stream, little_endian, &mut pos);
        let author: [u8; 32] = utils::read(stream, little_endian, &mut pos);
        let department: [u8; 32] = utils::read(stream, little_endian, &mut pos);
        let project: [u8; 32] = utils::read(stream, little_endian, &mut pos);
        let subject: [u8; 32] = utils::read(stream, little_endian, &mut pos);
        let timestamp = utils::read(stream, little_endian, &mut pos);
        let utc_time_offset = utils::read(stream, little_endian, &mut pos);
        let time_quality = utils::read(stream, little_endian, &mut pos);
        let timer_id: [u8; 32] = utils::read(stream, little_endian, &mut pos);

        (
            pos,
            Hdblock {
                position,
                block_type,
                block_size,
                data_group_block,
                file_comment,
                program_block,
                data_group_number,
                date,
                time,
                author,
                department,
                project,
                subject,
                timestamp,
                utc_time_offset,
                time_quality,
                timer_id,
            },
        )
    }

    fn write(&self, start_position: usize, little_endian: bool) -> Vec<u8> {
        let mut array = Vec::new();

        array.append(&mut utils::write(start_position, little_endian));
        array.append(&mut self.block_type.to_vec());
        array.append(&mut utils::write(self.block_size, little_endian));
        array.append(&mut utils::write(self.data_group_block, little_endian));
        array.append(&mut utils::write(self.file_comment, little_endian));
        array.append(&mut utils::write(self.program_block, little_endian));
        array.append(&mut utils::write(self.data_group_number, little_endian));
        array.append(&mut self.date.to_vec());
        array.append(&mut self.time.to_vec());
        array.append(&mut self.author.to_vec());
        array.append(&mut self.department.to_vec());
        array.append(&mut self.project.to_vec());
        array.append(&mut self.subject.to_vec());
        array.append(&mut utils::write(self.timestamp, little_endian));
        array.append(&mut utils::write(self.utc_time_offset, little_endian));
        array.append(&mut utils::write(self.time_quality, little_endian));
        array.append(&mut self.timer_id.to_vec());

        array
    }
}

impl Hdblock {
    pub fn data_group(&self) -> usize {
        self.data_group_block as usize
    }
    pub fn comment(&self, stream: &[u8], little_endian: bool) -> String {
        let (_pos, tx) = Txblock::read(stream, self.file_comment as usize, little_endian);
        tx.name()
    }
    pub fn first_data_group(&self, stream: &[u8], little_endian: bool) -> Dgblock {
        if self.data_group_block == 0 {
            panic!("No data group found!");
        }

        let (_pos, data_group) =
            Dgblock::read(stream, self.data_group_block as usize, little_endian);

        data_group
    }

    pub fn default() -> Self {
        Self::new(
            0usize, [0u8; 2], 0u16, 0u32, 0u32, 0u32, 0u16, [0u8; 10], [0u8; 8], [0u8; 32],
            [0u8; 32], [0u8; 32], [0u8; 32], 0u64, 0i16, 0u16, [0u8; 32],
        )
    }
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        position: usize,
        block_type: [u8; 2],
        block_size: u16,
        data_group_block: u32,
        file_comment: u32,
        program_block: u32,
        data_group_number: u16,
        date: [u8; 10],
        time: [u8; 8],
        author: [u8; 32],
        department: [u8; 32],
        project: [u8; 32],
        subject: [u8; 32],
        timestamp: u64,
        utc_time_offset: i16,
        time_quality: u16,
        timer_id: [u8; 32],
    ) -> Self {
        Self {
            position,
            block_type,
            block_size,
            data_group_block,
            file_comment,
            program_block,
            data_group_number,
            date,
            time,
            author,
            department,
            project,
            subject,
            timestamp,
            utc_time_offset,
            time_quality,
            timer_id,
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::utils;

    use super::*;

    #[test]
    fn read() {
        let hd_data = [
            0x48, 0x44, 0xD0, 0x00, 0xD8, 0xDF, 0x10, 0x00, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x06, 0x00, 0x32, 0x32, 0x3A, 0x31, 0x31, 0x3A, 0x32, 0x30, 0x31, 0x38,
            0x31, 0x34, 0x3A, 0x32, 0x36, 0x3A, 0x33, 0x35, 0x4A, 0x61, 0x63, 0x6B, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x46, 0xF9,
            0x75, 0x78, 0x69, 0x15, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x6F, 0x63, 0x61, 0x6C, 0x20,
            0x50, 0x43, 0x20, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x54,
            0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x58,
            0xCC, 0x02, 0x3C, 0x48, 0x44, 0x63, 0x6F, 0x6D, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x78,
            0x6D, 0x6C, 0x6E, 0x73, 0x3D, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x77,
            0x77, 0x77, 0x2E, 0x61, 0x73, 0x61, 0x6D, 0x2E, 0x6E, 0x65, 0x74, 0x2F, 0x6D, 0x64,
            0x66, 0x2F, 0x76, 0x34, 0x22, 0x3E, 0x3C, 0x54, 0x58, 0x3E, 0x44, 0x61, 0x74, 0x65,
            0x3A, 0x20, 0x32, 0x32, 0x2E, 0x31, 0x31, 0x2E, 0x32, 0x30, 0x31, 0x38, 0x0D, 0x0A,
            0x54, 0x69, 0x6D, 0x65, 0x3A, 0x20, 0x31, 0x35, 0x3A, 0x32, 0x37, 0x0D, 0x0A, 0x52,
            0x65, 0x63, 0x6F, 0x72, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x44, 0x75, 0x72, 0x61, 0x74,
            0x69, 0x6F, 0x6E, 0x3A, 0x20, 0x30, 0x30, 0x3A, 0x30, 0x30, 0x3A, 0x31, 0x32, 0x0D,
            0x0A, 0xA7, 0x40, 0x0D, 0x0A, 0x44, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x3A,
            0x20, 0x54, 0x65, 0x73, 0x74, 0x0D, 0x0A, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x6D,
            0x65, 0x6E, 0x74, 0x3A, 0x20, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x6D, 0x65, 0x6E,
            0x74, 0x0D, 0x0A, 0x57, 0x6F, 0x72, 0x6B, 0x73, 0x70, 0x61, 0x63, 0x65, 0x3A, 0x20,
            0x57, 0x6F, 0x72, 0x6B, 0x73, 0x70, 0x61, 0x63, 0x65, 0x0D, 0x0A, 0x44, 0x65, 0x76,
            0x69, 0x63, 0x65, 0x73, 0x3A, 0x20, 0x45, 0x54, 0x4B, 0x20, 0x74, 0x65, 0x73, 0x74,
            0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x3A, 0x31, 0x0D, 0x0A, 0x50, 0x72, 0x6F,
            0x67, 0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
            0x6F, 0x6E, 0x3A, 0x20, 0x41, 0x53, 0x41, 0x50, 0x32, 0x5F,
        ];

        let (position, hd_block) = Hdblock::read(&hd_data, 0, true);

        println!("Length {}", position);
        assert_eq!(position, 208);

        assert_eq!(hd_block.block_size, 208);
        assert_eq!(hd_block.data_group_block, 1105880);
        assert_eq!(hd_block.file_comment, 272);
        assert_eq!(hd_block.program_block, 0);
        assert_eq!(hd_block.data_group_number, 6);
        assert!(utils::eq(
            &hd_block.date,
            &[0x32, 0x32, 0x3A, 0x31, 0x31, 0x3A, 0x32, 0x30, 0x31, 0x38,]
        ));
        assert!(utils::eq(
            &hd_block.time,
            &[0x31, 0x34, 0x3A, 0x32, 0x36, 0x3A, 0x33, 0x35,]
        ));
        assert!(utils::eq(
            &hd_block.author,
            &[
                0x4A, 0x61, 0x63, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00,
            ]
        ));
        assert!(utils::eq(
            &hd_block.department,
            &[
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00,
            ]
        ));
        assert!(utils::eq(
            &hd_block.project,
            &[
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00,
            ]
        ));
        assert!(utils::eq(
            &hd_block.subject,
            &[
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00,
            ]
        ));
        assert_eq!(hd_block.timestamp, 1542896795439737088);
        assert_eq!(hd_block.utc_time_offset, 0);
        assert_eq!(hd_block.time_quality, 0);
        assert!(utils::eq(
            &hd_block.timer_id,
            &[
                0x4C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x50, 0x43, 0x20, 0x52, 0x65, 0x66, 0x65, 0x72,
                0x65, 0x6E, 0x63, 0x65, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00,
            ]
        ));
    }

    #[test]
    fn write() {}
}
